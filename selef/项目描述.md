自我介绍：

17年本科毕业, 先后在一家小公司和百度工作，目前是在字节。一直以来主要的工作方向就是云服务控制台以及可观测这种，toB toD的业务都接触过。
技术栈的话个人这面就是react、微前端。

在百度主要是负责云上百度。云上百度就是一个云产品平台，相当于百度智能云的企业版、内网版,我这面负责的主要是产品线方向 总共承接20+产品线业务需求，基本每个q可以支持15+个产品线业务需求,可以说是业务需求量巨大。我这面工作主要是就是业务的支持、业务组件库的维护，以及最多时候也要同时负责其余4个人的业务需求分配工作。用到的核心技术栈就是使用qiankun实现微前端,另外采用了monorepo的组织形式，以及使用了pnpm更帖合monorepo的包管理工具。

目前在字节这面，主要是负责火山引擎的云监控以及内网的一个时序数据库平台叫Metrics。属于是前端领域里可观测这么一个方向。Metrics这面用户量巨大，属于是字节内部一个基础应用。基本所有研发后端系统都统一接入的一个日志打点这么一个服务。这面做的主要是针对Metrics可视化查询平台重构收尾。重构的过程中引入了faas。解决了一些实际问题。另外主要投入精力的就是云监控，云监控这面难点也是对接的业务线比较多有50+，响应对接oncall，维护对外的图表组件库。完成一些像grafana插件、历史流水线的


<!-- 在上一家公司的话 先后做过两个项目：
第一个项目是一个低代码平台，主要功能就是可以通过页面拖拽的形式去把自定义的组件（大多数是图表）拼装到画布上。另外就是组件的数据源，用户可以自定义，可以自己去绑定数据库 绑定表，通过配置一些基础的数据库操作，整理数据显示出来
第二个项目可能比较抽象，不算是常规项目吧，我们叫他数据通，功能上就是用户可以通过页面配置一套模拟人在页面操作的流程图，生成一套基于pupteer的脚本，用这个脚本可以完成将页面的数据爬下来，或者将后台数据放到页面上去，帮他填报进去
这个项目在当时从最开始一个人实验性做着，最后到部门主推的产品之一吧。 -->


<!-- 其余两家公司第一家主要是用node.js 写爬虫，用过express 写过一点后端 -->
<!-- 很快第一家公司倒闭，去第二家这家公司主要是做政府政务相关，这家公司主要是写过两个项目 -->


需要了解 主要架构是怎样的。
微前端的理解 qiankun 相当于html 加载器。和我们正常开发一个项目是没有什么区别的。同时。微前端的样式隔离 怎么做的？组件库多版本的冲突。

提这个点。劫持的css 给他们的css 加前缀。 缺点 类似于vue的一样 这种方法 所有的css

js 沙箱。

monorepo 整个组织是怎么做的？ 我们的monorepo 是为了项目的复用。提供给外包同学一个业务组件库。

monorepo 提一下需求编排 构建的处理，简单讲一下。

讲下这个monorepo 突出产品线，monorepo 

monorepo 迁移的话可能会出现的问题

怎么和产品线协调需求，对接的产品线比较多。

yarn 切到pnpm 安装pnpm 加速 构建加速。 需求编排。

遇到过的难点： 公有云项目接入，公有云项目整体用的amd, 而且整个项目里面写的有点乱，代码融合比较深，也没办法改成umd 或者es6 module这种。
项目重写的话又太麻烦。所以当时就是硬啃源码。首先把他们源码拿了过来，再入口的部分加入了一段js 通过立即实行函数的形式给window 上注入了当前子系统的声明周期函数。mount就是
((global) => {
  global['子应用的名称'] = {
    bootstrap: () => {
        // 可以设计一个runtime、bootstrap等模块加载完毕后结束的promise
    },
    mount: () => {
        // 执行runtime的start
    },
    unmount: () => {
        // do nothing
    },
  };
})(window);

另外就是他原来才用的都是amd资源，很多资源都是写死的他们的cdn地址 还不加跨域头，
所以当时的做法就是整体把他们所有的缓存资源整体都手动down了一分下来，放到了我们的bos 也就是文件对象存储服务器上了 解决了一大堆资源跨域问题

另外比较核心的点是直接引入的时候由于要去掉他们的部分代码 也就是他们的基座部分。那最后去了之后肯定有很多功能用不了，尤其是他们包加载的功能有个叫esl的百度很老开源的一个类似于require.js的库，去掉基座那个也没了，所以最后改成了 手动加载那个库 库的源码中在定义require和define变量后增加window.require = require，把require变量什么的再挂到window上去。

处理解决系统之间互相依赖问题
大概分为两种情况，第一种就是子系统A 依赖子系统B、子系统C。举个实际业务场景比如我们当时有个产品叫需求编排，他需要在他系统里同时对其他产品进行下单。也就是说这个系统里会用到其他子系统的内容。那我们当时采用的技术流程就是在构建子系统A的时候 先去使用babel 直接对系统B 和系统C直接进行babel转义。因为是直接进行babel转义, 对于系统A来说 系统B的引入方式就是个正常包。用起来比较方便,也不用操心会不会造成多react版本不统一得问题。

另外一种就是像我们的一部分子app 要嵌入到别人的系统当中去。比如说像我们审批系统这样。或者有时候我们的子产品就是像嵌入到别人的子系统，那这个时候我们也提供了iframe方案。iframe方案重点其实就是要解决多余的导航栏渲染，以及登录验证信息两个部分，我们的解决方案就是可以优先读取url上面带的tocken
另外要解决一些像样式上弹窗的问题。所以我们单独提供了一个react包。叫pro-iframe 这个包能实现xx功能。
// 其实可以思考下wujie的方案


实际的业务开发场景来说 比如A包依赖B包 B包可能是业务组件库， 那么b包代码修改了其实就是手动构建。
因为这种场景还是比较少的。所以手动构建并不麻烦。当然我们也有自己的解决办法比如使用nodeman 进行监听，当代码改变自动执行build。用来方便大家调试。

组件库部分，组件库采用得单包发布，主要是因为 迭代速度特别快。单包发布的好处是包和包之间互不影响。我们得考虑是当组件库稳定后 后面可以考虑发布成单包发布。另外同样也是由于迭代速度快，那么如果统一发布 那么会造成monorepo下不同子包内的组件库的版本都不一样，如果用yarn 或者npm 的话 会产生严重的依赖分身问题。项目包太大。
然后关于组件库的文档库部分，我们直接用的就是阿里的dumi 用他的话主要的考虑就是天然支持monorepo 另外就是文档的话直接用你组件的ts类型自动生成。能帮助我们写文档，也能提高大家写ts的水平。
发包的话就是本地发包,版本号就是大家手动管理。没有自动化，原因就是之前发包比较快，更希望赶紧写完赶紧发包测试。

// 生成页面 
// 哪部分是拖拽 状态管理， react。 性能优化 -> 方框 位置判断。
// 如何绑定的数据库，
// pupeteer 防止 不是 用法
// 突出哪一段
// 不提
// 头条 写一个请求的hook，要求是啥啊 useRequest() 外面的不一定
// fetch 入参。 变也会重新请求，Object 存一个唯一的key
// 
// useRequest();

// 只讲擅长的讲，
// react 状态管理 redux 响应式原理, 性能优化
// react 虚拟dom 同级组件的type是什么？
// fiber js 动画有侦 16点 时间切片


技术难点
项目一：实现流程
第一个项目 主要分为这么几个部分，第一个是包的定义，我们可以上传类似于echarts这种的包
第二个是组件的定义， 组件定义分三个部分 css html 和 js。其中如果你得css html中有id这种，后期我们做了一点正则优化。把id改了，防止样式覆盖。然后至于你这个组件能接收哪些指标项，这个也要你配一下。 比如你说你接受一个纵轴数据，一个横轴。那你配置一下。js的话， 主要是要写个函数。这个函数你会收到一个data。这个data就是页面上你通过配置拿到的数据库算完之后的数据,会有一个统一格式。
第三个部分是页面拖拽 拖拽部分大概设计了两个分层，第一层是视图层，主要是放你拖入得组件得代码。第二层是操作层，用来配置缩放拖拽这种操作；平时看到的就是视图层，当点击的时候，操作层才展示出来，并且在页面对应的位置上，生成一个操作框，拖拽实际上就是用的原生拖拽，onDrag,onDragSart，onDragEnd这种。拖拽的时候获取该dom的位置，每次拖拽能获取到当前dom的位置，下层跟着一起动就完了。
当你拖拽一个新组件得时候，我们会大概根据你页面上已加载得js diff下，有新的话 会重新算下当前页面依赖哪些js 然后重新加载下这些组件。这部分其实就是一个有向无环图求拓扑排序
然后就是配置你这个图，比如你这个支持配置数据源，那你这个操作层右上角会有个配置，配置时候先绑定数据源，

最后生成页面 就比较简单了，因为咱这个本身去掉操作层直接就是能用得html 都不用转。

另外最后针对项目进行了一定的优化 使用webpack bundle 大概看了下每个包的大小
优化了一些首屏加载速度这样，比如模块根据路由懒加载。或者把模块比较大的东西通过cdn返回了。
另外就是把像moment换成了day.js 然后就是我们那个东西不需要兼容老浏览器。所以当时把polyfill 版本拉高了一些。另外就是利用了浏览器缓存机制，多利用强缓存

关于数据部分 由于我们目标是大数据分析，算数据时候性能有很大问题，我们是通过交互流程解决此问题
默认数据是5分钟同步一次，每次只选中最新数据

我们是通过拖拽生成图表，看起来自定义高一些，但实际上也用不上这么能自定义化，毕竟好看的图表页面一般都是通过布局来实现的，其实只用将页面区分出区域即可，甚至为了好做 区域只用最多支持二分都行
这样做的好处是不容易做生成html

项目二: 实现流程
第二个项目得话，页面上除了普通得项目管理以外，核心部分在于一个流程脚本得控制
我们节点大概分为几个种类 第一个是普通节点，输入值，第二种条件节点，你可以写一些判断，第三种是循环节点。循环条件和判断条件是根据页面上你获取到的xpath去判断的。你选中的循环节点，那你这个循环次数就是你xpath代表的dom的数量
判断节点就是根据你页面伤是否存在某个dom或者某些值
xpath 我们肯定是要根据页面dom。避免不了手填。
如何采用cron规则去定时执行脚本。
比如安装得时候怎么修改用户得注册表，完成那种在页面上点击即可唤醒我这个本地app功能。
另外比如用户说我不想安装你这个app 但我想用你这个东西。因为你这个反爬比较好些。
那我这个东西也支持服务端采集，我设计的架构里 采集器和和客户端是完全可以分离的。
为了实现这个功能我这面也是单独写了一个简单的nodeServer 并没有用到express 和 koa这种。因为实际上这个东西就是一个启动任务 暂停任务、关闭任务的功能；
比如我这个东西怎么实现暂停功能，暂停的话其实就是内部设置了一个间隔5s的循环遍历一个全局状态。


项目三: 实现流程
第三个项目的话我这面还是主要是支持部分产品线业务线项目进度得同时，把控整体产品线业务需求排期，配合多路团队完成云上百度得建设。
同时为了提高前端开发效率，保持UI、UE规范同步更新，我们建设和维护了一套非常完善得业务组件库
另外就是有些产品线是自己有fe的，我们也负责给其他团队fe进行基础培训。有些团队fe可能就是随便找了个外包，面试什么得都是我们来。
这个项目整体架构就是用得微前端用的qiankun。项目整体架构分为两个部分，一个是核心基座，另外一部分是各个子项目现在挂在云上百度的子系统得六七是个吧，我们这面建得系统就得有40+
基座部分主要得功能 记录当前登录用户信息 放到redux中。统计页面白屏时间、子系统加载时间、serviceWorker、小流量测试这种
多个子项目组织最开始用的是monorepo 这种形式，就是将多个子系统放到一个项目下管理。 
相较于普通项目，我们为了更贴近monorepo这种组织形式，采用了pnpm 代替了传统的npm 或者是yarn
另外就是git工作流会有一定不同，因为项目都存放在一起，你不能说改一行代码把所有子产品全推上线了。所以我们上线的持续集成脚本里 多加了个git commit diff的工作。算出你影响了多少子模块，只构建那几个子模块
另外由于这么多项目

service worker的话目前我们也就是应用在网络条件不好的情况 我们设置了一个比如你要是200ms没有返回首页 那么使用本地缓存

// 比如你入口的时候

qiankun的原理 优势

基于qiankun的优化： 比如导航栏里面实际上是有产品菜单的。当用户鼠标悬浮到菜单时候，我们就用qiankun的预加载技术，把这个产品的入口等js 加载过来了，提高访问速度。


pnpm 优势
npm 幽灵依赖 就比如说你得子项目没有用到包a 但是另外的项目中用到包a了。他装了你没装 那你是能用的.
为什么呢？因为npm中比如你a 依赖b包 c 依赖b包 那要是最后都一层一层安装得话 他会导致npm包体积过大，所以会有依赖提升
也就是存储得时候是扁平化存的。但当你a 依赖得是1.0得b包 c依赖是得2.0得b 包那你这个时候用的b 优先是1.0 还是2.0呢？主要是参考的是你安装a包还是c包得顺序。

npm monorepo 下的依赖分身依赖分身其实就是常见的包会重复的问题。

另外就是我们对优化首页加载速度进行了哪些优化,第一个就是导航栏渲染得内容降到最低。只有一个空html
接下来页面就是同时触发两个请求一个是请求当前用户信息，另外是请求一个基于qiankun得子服务注册信息。

比如第一点：首次进入页面的时候我们根据页面的地址提前去请求对应的资源有一个prefetch的过程。


// 技术的点 比如说像如何去维护前端的这么一个子服务的一个状态。


业务上负责过的模块

云上百度本身就是类似于百度智能云 阿里云这种云平台，所以根据业务上划分主要分为两个部分，第一个是平台本身具备的功能，比如像首页、财务系统、权限系统、以及一些跟公司预算相关的 预算系统、合同下单平台、商机清理系统、资源、需求编排等业务系统；

我个人基本全都参与过业务开发，参与程度较深的为财务相关 比如合同 商机系统；

另外就是各个产品线业务方的系统，这面就是会有很多业务方向过来跟你提业务需求，我个人参与较多，印象较深的为streamcompute、ens；

难点其实主要是怎样平衡各个产品线的业务需求，平衡大家的工作。
首先对外的话我们自己做了一个人力需求管理系统，大家有什么业务需求，可以先找我，我们内部评估出一个具体可行的排期，然后与业务方进行沟通，比如我这个东西需要十天，从10号开始做，那你能不能接受，能接受,你就在系统里提，提完了我们会接受，在系统里有这么个备案。负责的fe 、rd都是谁，排期是什么时间。
另外比如说那你不接受，那我们就一起讲道理，是你觉得开发时间长了,还是开始时间晚了。开始时间晚了那我们有系统，你说我们就这么几个人，前面系统已经排满了，你自己去和自己老大沟通嘛，前端没人力。你要是觉得你高优，那你老大去和其他老大商量嘛，谁高优我们先做哪个都没问题，你要是自己老大够硬能插队 对于我们是没有任何问题的，开发时间长了这个事情大概率发生较低，因为前端开发周期大概率比后端开发周期短。有的话也是后端可能先做了，那我们就看能不能多人并行开发，或者是加加班赶一赶。

接下来就是保障一个需求怎么能按时完成，首先不能是你一个页面估10天对吧，那样肯定排不开，最后会不断找我老大投诉。所以我们就正常估，对于特别小的紧急需求比如线上bug 那你直接找对应产品的负责人，他来处理，那你如果说这个需求可能就一个小弹窗，里面一个表单。那我们就暂时估开发联调1天。前提是接口先在沙盒上测试通过。这里强调下一定要在沙盒测试通过，不能是你本机测试通过，沙盒上会有用户鉴权等问题，之前也遇到过一到联调时候发现沙盒环境不好使还要调整半天。大型需求，比如新系统接入，统一按照一个页面算3天。里面包括开发联调测试以及ue ui验收。

此外，我这面会要求自己前端要学会push产品线rd。因为对于rd来说这个就是我们产品线的活，他们不急的其实，他们比如约了10天，那他们可能老大好说话，或者确实够复杂这个东西，那他们会给你脱个一个月都有可能，那这个时候，你就得自己push产品线rd 让他们快点开发联调。要不然10天一过你后面得需求就上来了，你排不开得。你push不动得话 后果就要自己承担，后面得排期工作任务就比较累，压力就会比较大。如果rd就说不行我这个东西就可能开发联调不完，那你这个东西后面继续重新排队。看情况给你高优插入插入。我们这面也尽可能帮你去和其他产品线沟通，或者内部就给你匀一点时间出来。

此外的话我这面不接受任何预订，比如说我现在才6月，有人说这个需求我要预订你9月份20天人力，不接受。不接受大于1个月以后得排期。这样我无法保证时间,除此之外我这面也会每周给所有产品线pm、rd负责人发邮件，内容是进度安排，业务风险啊，排期表啊。

另外比如说对于有自己fe得业务线，我这面把他们得fe拉到一个群里，对他们提代码得cr以及回答他们得问题。

对内得话，其实就没那么多说法了，大家都很不错，都很负责。我们这面就是每个人都自己得backup 谁请假了另外的人都可以顶一顶，而且说实话这种业务需求都没太复杂，不是自己得backup得业务需求，多和提需求得人沟通，很快也能上手。技术栈都是一样的。


财务的话 主要是各种形式的账单、订单显示。图表这类的。自己业务上的内容，比如说像自动续费管理之类、代付规则之类的
另外财务这块有个很大的模块就是预算，怎么去制定预算这部分，这部分参与过。但不深入

商机系统，这个系统主要是统计用户有多少人下单，但是下单失败的。那么我们就认为这是一条商机，然后你们可以自己去联系用户，看看有没有什么办法。商机系统里的商机你是可以清洗的。或者你可以直接在我们商机系统去录入这种,这种直接录入的单子就有种像合同一样。大客户说我想在xx时间点前 购买你们这几样产品，那你不用在平台上挨个产品挨个买，交给我们就ok了。

用户权限的话 我们会根据我们百度组织架构的划分划分为了5级账户，L0、L1、L2、L3、L4。其中L4 为资源账户，就是你实际可以购买资源的账户，已上为组织账户。


另外就是

业务上稍微复杂得业务模型比如组织架构图得实现

比如streamcompute 代码编辑器核心流程的实现

那比如说技术上我们对项目中进行了哪些优化升级


// 比较有代表性的组件设计
1. order-info 
云上百度就是个云产品平台 那么肯定会涉及到下单问题。下单的话我们肯定底部会有一个footer，这个footer就是一个统一得组件。
这个footer 由于维护时间比较长，维护人比较多。基本谁都加过功能，然后谁也不敢动里面得逻辑。
因为下单得样式其实很复杂，他涉及到了多种情况，比如付费模式得不同（预付费模式还是后付费模式）、升配还是降配、折扣如何、用户是否开启了代付、是否在一些需求编排系统中 等不同状态要显示不同得内容。而且当时还有另外一个问题就是我们新建了一个业务组件库之后 就是我们现在维护得组件库，那么新老form 用得不是一个form 他api是不兼容得。如果pm加了一个功能 我们要同时在两个地方加相同得功能。所以我就一直打算重构他

那么我是怎么重构的。
首先我把核心得业务逻辑都封装到一个hook中，hook也是可以导出直接用的。这个hook 主要是用来计算 当前下一步按钮是否应该禁用，调用一些接口 获取代付、折扣状态。把整个组件应该有得状态信息給吐出来
然后组件得UI部分分为两个部分，第一个部分是根据当前状态就能展示出对应样式的footer内容, 这部分也是导出可用的
然后就是组件默认导出的实际的组件，基于新form 和刚才的footer内容以及hook获取的内容值进行拼接组装

那么跑回老代码库 我也是基于这三样东西就行组装，唯一的区别就在于 老代码中的form footer用的老form。但这里面比如说核心业务逻辑变了 或者ui变了
我大概率只需要改一个地方 老组件库版本升级即可解决大多数问题。
同时 我简化了之前很多无用的api设计。从原来每次要传10多个参数 到现在大多数情况就需要传4 5个这种。


2. text 
   我们也加入了比如是否可以复制内容，比如禁用时候的样式，比如加入文字超出时自动换行 是否有tooltip 提示这种

node js
nodejs 早年写过爬虫类的代码  用过express 写过一点后台

在百度这面用过nestjs 写过简单的增删差改 用的也就是orm 框架 链接的mysql @nestjs/typeorm
用了一些类似于过滤器 拦截器 这种封装了统一的接口返回格式


字节工作
1. grafana插件
调研，开发、对外的文档 都是自己搞得，以前端来做业务需求owner角度来做事。
调研。业务需求。让用户在自建的grafana上去看我们火山引擎云监控上的数据
了解业内怎么做的。腾讯云 和阿里云两个实现方式
grafana官网调研插件的种类。我们适合做哪种
grafana插件大概分为三种。一个是我们和阿里实现的数据源插件。可以配置数据，面板插件。根据数据绘制定义的图形。app插件腾讯的插件。数据源+面板+改变grafa一些其他的功能
首先接口请求怎么办？因为我们是火山外部调用。所有接口都要走openAPI。openAPI的鉴权我是怎么做的，将火山的sdk 源码扒下来改了下 commonjs => esm,去掉一些环境变量读取规则等。
另外就是需要掉哪些接口。
联调和测试。我是找rd要了一个开发机。装了一个docker 使用grafana官方提供的镜像。再开发机上去启动
单位和grafana对齐。变量的实现

2. 告警治理
上报的规则：js、白屏有就报警P1和P0 对于请求 5min之内所有请求错误数大于5 上报
接入后第一个就是对告警进行治理，去达到这个满足战备的一个状态。
我们用到了内场一个前端监控工具叫slardar 当然原来也略懂一些。
js报错。共性比较明显的。比如虚商环境下一直有一个报错，火山会被内部一些产品用iframe形式嵌套。只嵌套子应用而不嵌套导航栏。那我们有一个js的逻辑是 再导航栏渲染地域信息，这个就不行。js报错你需要给平台上报源码。这个就是官方提供了一个webpack插件。作用的就是当检测到你现在的环境是在公司统一编译环境下，build后会自动上报sourceMap

白屏矫正
白屏的原理是什么？
原理：
    1. 页面 load 完成之后等待一个 ric 和 raf，开始用 MutationObserver 监听 Dom 变化。
    2. 每次 Dom 发生变更，调度一次打分任务，时间在一个 ric 和一个 raf 之后。
注意： 有ErrorBoundary 的情况下需要手动上报白屏

请求错误，主要是兼容后端状态码200，但是返回错误格式

3. 国际化
国际化我这面主要主要用到的就是用lint-staged +hooksy 去做当代码提交时主动的触发一些自定义可执行的脚本，通常情况下是做代码自动格式化，代码检查
这里用处是在代码提交时，拿到当前diff的文件。把这个文件目录作为参数，通过脚本命令 传递给我们做翻译的库 我们叫starling 提供的一个cli
starling cli允许你配置一个执行文件，提供了一些对外暴露的生命周期，比如脚本执行开始，运行中（运行中分的很细，比如翻译中，替换中），代码提交中
我这面主要是用到了 几个点，第一个最重要的是自动翻译插件。他相当于能扫你的代码，通过ast检测到当前中文。然后调用starling 平台的api去上传翻译
并且替换你的代码我这面替换的规则是I18n.("key", "兜底中文")。再用他提供的插件，再代码顶部去添加一个I18n的引用。这个就是一个字符串检测。
最后在掉用他们的机翻插件，将我们刚才上传的翻译任务，机翻。
在引用上
后端接口上：一些原有xx为CN的字段取让他变成xx
页面交互上：由于文案长度变化一些布局的调整
依赖组件库上： 对齐调整

引用形式上做了哪些变化。调整APP入口逻辑
我们自己对外的组件库
4. 
monaco-editor 引入wasm 简述下wasm的思考过程


5. Faas
Faas 的特点，无需运维，自动扩缩容。再带的一些日志服务，上线迅速


