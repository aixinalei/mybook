您好，我这面17年毕业, 目前是在百度了，主要是负责云上百度产品线方向。云上百度就是一个云产品平台，相当于百度智能云的企业版、内网版,我这面负责的主要是产品线方向，这个方向主要就是承接各个单独的产品线提过来的前端需求，基本每个q可以支持15+个产品线业务需求,可以说是业务需求量巨大。我这面工作主要是就是业务的支持、业务组件库的维护，以及最多时候也要同时负责其余4个人的业务需求分配工作。具体得业务类型属于标准得B端控制台，大量的表单，表格，详情页。



<!-- 其余两家公司第一家主要是用node.js 写爬虫，用过express 写过一点后端 -->
很快第一家公司倒闭，去第二家这家公司主要是做政府政务相关，这家公司主要是写过两个项目
第一个项目是一个低代码平台，主要功能就是可以通过页面拖拽的形式去把自定义的组件（大多数是图表）拼装到画布上。另外就是组件的数据源，用户可以自定义，可以自己去绑定数据库 绑定表，通过配置一些基础的数据库操作，整理数据显示出来
第二个项目可能比较抽象，不算是常规项目吧，我们叫他数据通，功能上就是用户可以通过页面配置，生成一套基于pupteer的脚本，用这个脚本可以完成将页面的数据爬下来，或者将后台数据放到页面上去，帮他填报进去
这个项目在当时从最开始一个人实验性做着，最后到部门主推的产品之一吧。

技术栈的话个人这面就是react相关，vue写过，理解不多。


第一个介绍 太泛了。第一个百度云的内网版本，负责百度所有云产品的前端。产品的总数 总共有多少个。 整个百度内部云服务的前端平台 有xx个产品 的前端开发，项目是用monorepo 和微前端做的。 

需要了解 主要架构是怎样的。
微前端的理解 qiankun 相当于html 加载器。和我们正常开发一个项目是没有什么区别的。同时。微前端的样式隔离 怎么做的？组件库多版本的冲突。

提这个点。劫持的css 给他们的css 加前缀。 缺点 类似于vue的一样 这种方法 所有的css

js 沙箱。

monorepo 整个组织是怎么做的？ 我们的monorepo 是为了项目的复用。提供给外包同学一个业务组件库。

monorepo 提一下需求编排 构建的处理，简单讲一下。

讲下这个monorepo 突出产品线，monorepo 怎么部署的。

怎么和产品线协调需求，对接的产品线比较多。

yarn 切到pnpm 安装pnpm 加速 构建加速。 需求编排。


// 生成页面 
// 哪部分是拖拽 状态管理， react。 性能优化 -> 方框 位置判断。
// 如何绑定的数据库，
// pupeteer 防止 不是 用法
// 突出哪一段
// 不提
// 头条 写一个请求的hook，要求是啥啊 useRequest() 外面的不一定
// fetch 入参。 变也会重新请求，Object 存一个唯一的key
// 
// useRequest();

// 只讲擅长的讲，
// react 状态管理  redux 响应式原理, 性能优化
// react 虚拟dom 同级组件的type是什么？
// fiber js 动画有侦 16点 时间切片




技术难点
项目一：实现流程
第一个项目 主要分为这么几个部分，第一个是包的定义，我们可以上传类似于echarts这种的包
第二个是组件的定义， 组件定义分三个部分 css html 和 js。其中如果你得css html中有id这种，后期我们做了一点正则优化。把id改了，防止样式覆盖。然后至于你这个组件能接收哪些指标项，这个也要你配一下。 比如你说你接受一个纵轴数据，一个横轴。那你配置一下。js的话， 主要是要写个函数。这个函数你会收到一个data。这个data就是页面上你通过配置拿到的数据库算完之后的数据,会有一个统一格式。
第三个部分是页面拖拽 拖拽部分大概设计了两个分层，第一层是视图层，主要是放你拖入得组件得代码。第二层是操作层，用来配置缩放拖拽这种操作；平时看到的就是视图层，当点击的时候，操作层才展示出来，并且在页面对应的位置上，生成一个操作框，拖拽实际上就是用的原生拖拽，onDrag,onDragSart，onDragEnd这种。拖拽的时候获取该dom的位置，每次拖拽能获取到当前dom的位置，下层跟着一起动就完了。
当你拖拽一个新组件得时候，我们会大概根据你页面上已加载得js diff下，有新的话 会重新算下当前页面依赖哪些js 然后重新加载下这些组件。这部分其实就是一个有向无环图求拓扑排序
然后就是配置你这个图，比如你这个支持配置数据源，那你这个操作层右上角会有个配置，配置时候先绑定数据源，
当时写的不好，写的是直接前端拼了个sql 给后端发过去，后端直接执行。因为那个时候前后端一起写，
然后后端这面主要有个优化，就是根据有个项目
最后生成页面 就比较简单了，因为咱这个本身去掉操作层直接就是能用得html 都不用转。


项目二: 实现流程
第二个项目得话，页面上除了普通得项目管理以外，核心部分在于一个流程脚本得控制
我们节点大概分为几个种类 第一个是普通节点，输入值，第二种条件节点，你可以写一些判断，第三种是循环节点。循环条件和判断条件是根据页面上你获取到的xpath去判断的。你选中的循环节点，那你这个循环次数就是你xpath代表的dom的数量
判断节点就是根据你页面伤是否存在某个dom或者某些值
xpath 我们肯定是要根据页面dom。避免不了手填。


项目三: 实现流程
第三个项目的话我这面还是主要是支持部分产品线业务线项目进度得同时，把控整体产品线业务需求排期，配合多路团队完成云上百度得建设。
同时为了提高前端开发效率，保持UI、UE规范同步更新，我们建设和维护了一套非常完善得业务组件库
另外就是有些产品线是自己有fe的，我们也负责给其他团队fe进行基础培训。有些团队fe可能就是随便找了个外包，面试什么得都是我们来。
这个项目整体架构就是用得微前端用的qiankun。项目整体架构分为两个部分，一个是核心基座，另外一部分是各个子项目现在挂在云上百度的子系统得六七是个吧，我们这面建得系统就得有40+
基座部分主要得功能 记录当前登录用户信息 放到redux中。统计页面白屏时间、子系统加载时间、serviceWorker、小流量测试这种
多个子项目组织最开始用的是monorepo 这种形式，就是将多个子系统放到一个项目下管理。 
相较于普通项目，我们为了更贴近monorepo这种组织形式，采用了pnpm 代替了传统的npm 或者是yarn
另外就是git工作流会有一定不同，因为项目都存放在一起，你不能说改一行代码把所有子产品全推上线了。所以我们上线的持续集成脚本里 多加了个git commit diff的工作。算出你影响了多少子模块，只构建那几个子模块
另外由于这么多项目 
// 比如你入口的时候

qiankun的原理 优势

基于qiankun的优化： 比如导航栏里面实际上是有产品菜单的。当用户鼠标悬浮到菜单时候，我们就用qiankun的预加载技术，把这个产品的入口等js 加载过来了，提高访问速度。


npm 幽灵依赖 就比如说你得子项目没有用到包a 但是另外的项目中用到包a了。他装了你没装 那你是能用的.
为什么呢？因为npm中比如你a 依赖b包 c 依赖b包 那要是最后都一层一层安装得话 他会导致npm包体积过大，所以会有依赖提升
也就是存储得时候是扁平化存的。但当你a 依赖得是1.0得b包 c依赖是得2.0得b 包那你这个时候用的b 优先是1.0 还是2.0呢？主要是参考的是你安装a包还是c包得顺序。







